# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_cv_ops.ipynb.

# %% auto 0
__all__ = ['multi_otsu', 'remove_small_objects', 'fill_holes_in_objects', 'convert_to_rotated_rectangles']

# %% ../nbs/02_cv_ops.ipynb 3
import pandas as pd
from pathlib import Path
import numpy as np
from tqdm import tqdm
from fastcore.all import *
import matplotlib as mpl
import matplotlib.pyplot as plt
from fastcore.all import *
import shutil
import cv2
from typing import Union, List, Tuple, Dict
import pandas as pd
from skimage import io, morphology, measure
from skimage.filters import threshold_multiotsu
from scipy.ndimage import (label, sum, binary_fill_holes)
import os
from tqdm.auto import tqdm
import argparse

# %% ../nbs/02_cv_ops.ipynb 7
def multi_otsu(img:np.array, classes:int=3)->np.array:
    """Multi-Otsu thresholding-> returns image of type np.uint8"""
    thresholds = threshold_multiotsu(img, classes)
    regions = np.digitize(img, bins=thresholds)
    # Scale the regions to span full 8-bit range (0-255) by multiplying by 255/(num_classes-1)
    # E.g. for 3 classes, maps [0,1,2] to [0,127,255]
    regions = regions*(255//(classes-1))
    return regions.astype(np.uint8)

# %% ../nbs/02_cv_ops.ipynb 8
def remove_small_objects(
        binary_mask:np.ndarray,  # np.ndarry
        size_threshold:Union[float, int] # 
        ):
    'From a binary mask remove small objects'
    labeled_mask, num_labels = label(binary_mask)
    sizes = sum(binary_mask, labeled_mask, range(num_labels + 1))
    mask_sizes = sizes[labeled_mask]
    binary_mask = mask_sizes > size_threshold
    return binary_mask

# %% ../nbs/02_cv_ops.ipynb 9
def fill_holes_in_objects(binary_mask):
    'Fill holes inside binary mask'
    filled_mask = binary_fill_holes(binary_mask)
    return filled_mask

# %% ../nbs/02_cv_ops.ipynb 10
def convert_to_rotated_rectangles(binary_mask):
    'Convert binary mask arbitary from to  rotated rectange '
    contours, _ = cv2.findContours(binary_mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    new_mask = np.zeros_like(binary_mask, dtype=np.uint8)
    for contour in contours:
        rect = cv2.minAreaRect(contour)
        box = cv2.boxPoints(rect)
        box = np.intp(box)
        cv2.drawContours(new_mask, [box], 0, (1), -1)
    return new_mask
